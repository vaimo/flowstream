import { Project, ProjectMetrics } from './types';

const OPENAI_ENDPOINT = 'https://api.openai.com/v1/chat/completions';
const DEFAULT_MODEL = process.env.OPENAI_MODEL || 'gpt-4o-mini';

export interface AiSuggestionInput {
  project: Project | null;
  latestMetrics: ProjectMetrics;
  historicalMetrics?: ProjectMetrics[];
  excludeTexts?: Set<string>;
  completedSuggestionText?: string;
}

export interface AiSuggestion {
  text: string;
  rationale: string;
}

export async function generateAiSuggestions(input: AiSuggestionInput): Promise<AiSuggestion[]> {
  const apiKey = process.env.OPENAI_API_KEY;
  if (!apiKey) {
    return [];
  }

  const { project, latestMetrics, historicalMetrics = [], excludeTexts = new Set(), completedSuggestionText } = input;

  const groupedHistory = historicalMetrics
    .slice()
    .sort((a, b) => b.month.localeCompare(a.month))
    .slice(0, 3)
    .map((metric) => `- ${metric.month}: LCP ${metric.perf.coreWebVitals.lcp}s, INP ${Math.round(metric.perf.coreWebVitals.inp)}ms, CLS ${metric.perf.coreWebVitals.cls}, A11y ${Math.round(metric.perf.accessibility * 100)}%, Throughput ${Math.round(metric.flow.throughputRatio * 100)}%, Quality Issues ${metric.flow.qualityIssuesCount ?? 0}`)
    .join('\n');

  const prompt = `Generate up to 3 actionable accessibility and delivery improvements.
Project: ${project?.name ?? input.latestMetrics.projectId}
Domain: ${project?.url ?? 'unknown'}
Latest month ${latestMetrics.month} metrics:
  - LCP: ${latestMetrics.perf.coreWebVitals.lcp}s
  - INP: ${Math.round(latestMetrics.perf.coreWebVitals.inp)}ms
  - CLS: ${latestMetrics.perf.coreWebVitals.cls}
  - Accessibility: ${Math.round(latestMetrics.perf.accessibility * 100)}%
  - Throughput: ${Math.round(latestMetrics.flow.throughputRatio * 100)}%
  - WIP items: ${latestMetrics.flow.wipCount ?? Math.round(latestMetrics.flow.wipRatio * (latestMetrics.flow.totalItemsCount ?? 0))}
  - Throughput items: ${latestMetrics.flow.throughputCount ?? Math.round(latestMetrics.flow.throughputRatio * (latestMetrics.flow.totalItemsCount ?? 0))}
  - Quality issues (14d): ${latestMetrics.flow.qualityIssuesCount ?? 0}
Historical trend (latest to oldest):
${groupedHistory || '- no history available'}
${completedSuggestionText ? `Previously completed suggestion: "${completedSuggestionText}"` : ''}

Rules:
- Focus on improving web performance, accessibility, or delivery flow.
- Each suggestion must include a one sentence rationale explaining why.
- Return JSON array of objects with keys "text" and "rationale".
- Avoid suggestions already in this list: ${Array.from(excludeTexts).join('; ') || 'none'}.
- Keep each suggestion under 160 characters.`;

  try {
    const response = await fetch(OPENAI_ENDPOINT, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${apiKey}`,
      },
      body: JSON.stringify({
        model: DEFAULT_MODEL,
        response_format: { type: 'json_object' },
        messages: [
          {
            role: 'system',
            content: 'You are a product operations co-pilot. Respond with a JSON object: {"suggestions": [{"text": string, "rationale": string}, ...]}.'
          },
          {
            role: 'user',
            content: prompt,
          },
        ],
      }),
    });

    if (!response.ok) {
      throw new Error(`OpenAI API error ${response.status}`);
    }

    const json = await response.json();
    const messageContent = json?.choices?.[0]?.message?.content;
    if (!messageContent) {
      throw new Error('No content returned from OpenAI');
    }

    const parsed = JSON.parse(messageContent);
    const suggestions = Array.isArray(parsed?.suggestions) ? parsed.suggestions : [];

    return suggestions
      .filter((item: any) => item && typeof item.text === 'string')
      .map((item: any) => ({
        text: item.text.trim(),
        rationale: typeof item.rationale === 'string' ? item.rationale.trim() : 'Generated by AI based on the latest metrics.',
      }))
      .filter(item => !excludeTexts.has(item.text));
  } catch (error) {
    console.warn('OpenAI suggestion generation failed:', error);
    return [];
  }
}
